import random
from sqlite3 import IntegrityError

import AaioAPI
import requests
from AaioAPI import Aaio
from aiogram import Router, F, Bot
from aiogram.filters import CommandStart, CommandObject
from aiogram.fsm.context import FSMContext
from aiogram.types import Message, FSInputFile, CallbackQuery
from aiogram.utils.markdown import hbold

from funcs.get_crypto_balances import convert_to_rubles, get_usd_to_rubles_rate
from funcs.payment import create_payoff
from tgbot.keyboards.inline import wallet_keyboard, settings_keyboard, choose_currency_keyboard, verif_keyboard, \
    about_service_keyboard, top_up_keyboard, invoice_keyboard, choose_method_keyboard, exchange_keyboard
from tgbot.keyboards.reply import start_keyboard, currency_choose
from tgbot.misc.states import Payment, Popoln, CurrencyExchange
from tgbot.services.sqlite import Database

user_router = Router()


@user_router.message(CommandStart())
async def user_start(message: Message, command: CommandObject):
    db = Database()
    blacklisted_users = [i[0] for i in db.select_all_blacklisted_users()]
    if message.from_user.id in blacklisted_users:
        return
    try:
        db.add_user(message.from_user.id,
                    message.from_user.full_name,
                    message.from_user.username,
                    "False", str(message.date.date()))
        db.add_crypto_balance(message.from_user.id)
    except IntegrityError:
        pass
    text = hbold("üîª–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –º—É–ª—å—Ç–∏–≤–∞–ª—é—Ç–Ω—ã–π –∫—Ä–∏–ø—Ç–æ-–æ–±–º–µ–Ω–Ω–∏–∫ Remitano!"
                 "\n\nRemitano –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–∞–∫ –∫–æ—à–µ–ª–µ–∫ –¥–ª—è —É–¥–æ–±–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π —Å –æ—Å–Ω–æ–≤–Ω—ã–º–∏ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞–º–∏.")
    await message.answer(text=f"{text}", reply_markup=start_keyboard())


@user_router.message(F.text == "üíº –ö–æ—à–µ–ª–µ–∫")
async def wallet(message: Message, bot: Bot):
    await bot.send_chat_action(chat_id=message.from_user.id, action="typing")
    db = Database()
    user = db.select_user(user_id=message.from_user.id)
    users_crypto_balance = db.select_crypto_balances(user_id=message.from_user.id)
    usdt = users_crypto_balance[2]
    eth = users_crypto_balance[3]
    btc = users_crypto_balance[4]
    currency = user[8]
    if currency == "USD":
        currency_sign = "$"
    else:
        currency_sign = "‚ÇΩ"
    verification_status = "‚úÖ –î–∞" if user[3] == "True" else "‚ùå –ù–µ—Ç"
    await message.answer_photo(photo=FSInputFile(path="/exchanger/images/wallet_button.jpeg"),
                               caption=f"üíº{hbold('–ö–æ—à–µ–ª–µ–∫')}:\n"
                                       f"\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ"
                                       f"\nüìë –í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è: {verification_status}"
                                       f"\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ"
                                       f"\n{hbold(f'üè¶ –û–±—â–∏–π –±–∞–ª–∞–Ω—Å {round(convert_to_rubles(usdt, eth, btc, user[4], currency), 2)}{currency_sign}')}"
                                       f"\n{hbold(f'üíµ –§–∏–∞—Ç–Ω—ã–π –±–∞–ª–∞–Ω—Å: {round(convert_to_rubles(usdt, eth, btc, user[4], currency) - convert_to_rubles(usdt, eth, btc, 0, currency), 2)}{currency_sign}')}"
                                       f"\n{hbold(f'üóÑ ID: {message.from_user.id}')}"
                                       f"\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ"
                                       f"\nüîê –ö—Ä–∏–ø—Ç–æ–ø–æ—Ä—Ç—Ñ–µ–ª—å:"
                                       f"\n\n{round(btc, 2)} BTC"
                                       f"\n{round(usdt, 2)} USDT"
                                       f"\n{round(eth, 2)} ETH"
                                       f"\n\nüìà –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –æ–Ω–ª–∞–π–Ω: {hbold(random.randint(750, 900))}",
                               reply_markup=wallet_keyboard())


@user_router.callback_query(F.data == "settings")
async def settings(call: CallbackQuery):
    await call.message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=settings_keyboard())


@user_router.callback_query(F.data == "cur")
async def cur(call: CallbackQuery):
    await call.message.edit_text("–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞–ª—é—Ç—É:", reply_markup=choose_currency_keyboard())


@user_router.callback_query(F.data.startswith("valut:"))
async def valut(call: CallbackQuery):
    db = Database()
    db.update_user_currency(call.from_user.id, call.data.split(":")[1])
    await call.message.edit_text("‚úÖ –í–∞–ª—é—Ç–∞ —É—Å–ø–µ—à–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")


@user_router.callback_query(F.data == "veref")
async def verf(call: CallbackQuery):
    db = Database()
    user = db.select_user(user_id=call.message.chat.id)
    if user[3] == "False":
        text = "ü§∑üèª‚Äç‚ôÄÔ∏è –ö —Å–æ–∂–∞–ª–µ–Ω–∏—é, –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç –Ω–µ –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω, —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞—Ç—å –∞–∫–∫–∞—É–Ω—Ç, –≤—ã –º–æ–∂–µ—Ç–µ —ç—Ç–æ " \
               "—Å–¥–µ–ª–∞—Ç—å, –Ω–∞–∂–∞–≤ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –∏ –Ω–∞–ø–∏—Å–∞–≤ '–í–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏—è' –≤ —Ç–µ—Ö.–ø–æ–¥–¥–µ—Ä–∂–∫—É, —Å–ø–∞—Å–∏–±–æ!" \
               "\n\nüî∑ –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç –≤ –æ—á–µ—Ä–µ–¥–∏ –∫ –≤—ã–ø–ª–∞—Ç–µ." \
               "\n\nüî∑ –û—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –ª–∏–º–∏—Ç–æ–≤ –Ω–∞ –≤—ã–≤–æ–¥ —Å—Ä–µ–¥—Å—Ç–≤." \
               "\n\nüî∑ –£–≤–µ–ª–∏—á–µ–Ω–∏–µ –¥–æ–≤–µ—Ä–∏—è —Å–æ —Å—Ç–æ—Ä–æ–Ω—ã –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ü–∏–∏, –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ –∞–∫–∫–∞—É–Ω—Ç–∞."
        verified = False
    else:
        text = "–í–∞—à –∞–∫–∫–∞—É–Ω—Ç –≤–µ—Ä–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω ‚úÖ"
        verified = True
    await call.message.answer_photo(photo=FSInputFile(path="/exchanger/images/verification.jpeg"),
                                    caption=text,
                                    reply_markup=verif_keyboard(verified))


@user_router.callback_query(F.data == "delmsg")
async def delmsg(call: CallbackQuery):
    await call.message.delete()
    await state.clear()


@user_router.callback_query(F.data == "back_pay")
async def back_pay(call: CallbackQuery):
    await call.message.delete()
    await state.clear()


@user_router.message(F.text == "üî∑ –û —Å–µ—Ä–≤–∏—Å–µ")
async def about_service(message: Message, bot: Bot):
    capacity_percent = random.randint(50, 100)
    black_square = round(capacity_percent / 16.6) * 'üî≥'
    white_square = (6 - len(black_square)) * '‚¨úÔ∏è'
    text = "üõ°–ù–∞–¥–µ–∂–Ω–∞—è, –±–µ–∑–æ–ø–∞—Å–Ω–∞—è –∏ —É–¥–æ–±–Ω–∞—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏—è –¥–ª—è –≤—Å–µ—Ö –≤–∞—à–∏—Ö –ø–æ–∫—É–ø–æ–∫ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç—ã!" \
           "\n\n–í –æ—Ç–ª–∏—á–∏–µ –æ—Ç –º–Ω–æ–≥–∏—Ö –Ω–∞—à–∏—Ö –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤, –º—ã –ø—Ä–µ–¥–ª–∞–≥–∞–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –ø–æ–∫—É–ø–∞—Ç—å, –ø—Ä–æ–¥–∞–≤–∞—Ç—å –∏ —Ö—Ä–∞–Ω–∏—Ç—å –±–æ–ª–µ–µ " \
           "40 —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç, –≤–∫–ª—é—á–∞—è –æ—Å–Ω–æ–≤–Ω—ã–µ –º–æ–Ω–µ—Ç—ã, —Ç–∞–∫–∏–µ –∫–∞–∫ –ë–∏—Ç–∫–æ–π–Ω –∏ –≠—Ñ–∏—Ä–∏—É–º. " \
           "\n\n–î—Ä—É–≥–∏–µ –∫–ª—é—á–µ–≤—ã–µ –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –≤–∫–ª—é—á–∞—é—Ç –≤ —Å–µ–±—è:" \
           "\n\nüîª–ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å—é —Å–µ—Ä–≤–∏—Å–∞ 24/7" \
           "\n\nüîª–õ—É—á—à–∏–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏ –∫–æ–Ω–≤–µ—Ä—Å–∏–∏" \
           "\n\nüîª–° –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –≤–∞—Ä–∏–∞–Ω—Ç–∞–º–∏ –æ–ø–ª–∞—Ç—ã" \
           "\n\n–ü–æ—á–µ–º—É —Å—Ç–æ–∏—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —Å –Ω–∞–º–∏?" \
           "\n\nüßëüèª‚Äçüíª –ù–∞—à–∏ –ø–∞—Ä—Ç–Ω–µ—Ä—ã:" \
           "\n–ú—ã –≥–æ—Ä–¥–∏–º—Å—è —Ç–µ–º, —á—Ç–æ —Ä–∞–±–æ—Ç–∞–µ–º —Å —Ä—è–¥–æ–º –æ–ø—ã—Ç–Ω—ã—Ö, —Ä–µ–≥—É–ª–∏—Ä—É–µ–º—ã—Ö –±–∞–Ω–∫–æ–≤—Å–∫–∏—Ö –ø–∞—Ä—Ç–Ω–µ—Ä–æ–≤, —á—Ç–æ –ø–æ–∑–≤–æ–ª—è–µ—Ç –Ω–∞–º " \
           "–ø—Ä–µ–¥–ª–∞–≥–∞—Ç—å –≤–∞–º –ø–µ—Ä–µ–¥–æ–≤—ã–µ –∏ –Ω–∞–¥–µ–∂–Ω—ã–µ —É—Å–ª—É–≥–∏." \
           "\n\nüîê –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å –∏ –æ—Ö—Ä–∞–Ω–∞:" \
           "\n–° –º–æ–º–µ–Ω—Ç–∞ –Ω–∞—à–µ–≥–æ –∑–∞–ø—É—Å–∫–∞ –≤ 2017 –≥–æ–¥—É Remitano —É—Å—Ç–∞–Ω–æ–≤–∏–ª –æ—Ç—Ä–∞—Å–ª–µ–≤–æ–π —Å—Ç–∞–Ω–¥–∞—Ä—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ –∑–∞—â–∏—Ç—ã." \
           "\n\nCoindirect –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –æ–±—à–∏—Ä–Ω—ã–π –æ–ø—ã—Ç –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è –¥–µ–Ω–µ–≥ —á–µ—Ä–µ–∑ —Å–µ—Ç—å –±–∞–Ω–∫–æ–≤ –∏ –ø–æ—Å—Ç–∞–≤—â–∏–∫–æ–≤ " \
           "–ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏ –≤ —Ä–∞–∑–Ω—ã—Ö —Å—Ç—Ä–∞–Ω–∞—Ö." \
           "\n\n–ó–∞–≥—Ä—É–∂–µ–Ω–Ω–æ—Å—Ç—å –±–æ—Ç–∞:" \
           f"\n{black_square + white_square} {capacity_percent}%"

    await message.answer_photo(photo=FSInputFile(path="/exchanger/images/about_service.jpeg"),
                               caption=text,
                               reply_markup=about_service_keyboard())


@user_router.callback_query(F.data == "popoln")
async def popoln(call: CallbackQuery):
    await call.message.answer_photo(photo=FSInputFile(path="/exchanger/images/top_up.jpeg"),
                                    caption="–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞—Ä–∏–∞–Ω—Ç –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞:",
                                    reply_markup=top_up_keyboard())


@user_router.callback_query(F.data == "deposit_card")
async def deposit_card(call: CallbackQuery, state: FSMContext):
    await call.message.edit_caption(caption=f"–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è:\n–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ - {hbold('1000‚ÇΩ')}")
    await state.set_state(Payment.sum)


@user_router.message(Payment.sum)
async def payment_sum(message: Message, state: FSMContext):
    try:
       int(message.text)
    except:
    if int(message.text) < 100:
        await message.answer("–í—ã –≤–≤–µ–ª–∏ —Å—É–º–º—É –º–µ–Ω—å—à–µ 100‚ÇΩ")
        return
    payment_id = f"{message.from_user.id}:{random.randint(100, 999)}"
    merchant_id = "46cdb37e-cb1d-45dd-b426-eca83015cfbe"
    secret_key = "7c51da4caad10af4210e95b255d38c91"
    desc = '–ó–∞–∫–∞–∑'
    url_aaio = AaioAPI.pay(merchant_id, message.text, "RUB", secret_key, desc)
    await state.update_data(payment_url=url_aaio)
    await state.update_data(top_up=message.text)
    text = "‚ôªÔ∏è –û–ø–ª–∞—Ç–∞:" \
           f"\n\n–°—É–º–º–∞: {message.text}‚ÇΩ" \
           "\n\n‚ö†Ô∏è –°—á–µ—Ç –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 15 –º–∏–Ω—É—Ç!" \
           "\n‚ö†Ô∏è –í–ê–ñ–ù–û! –û–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ—Å–ª–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è, –Ω–µ –∑–∞–±—É–¥—å—Ç–µ –Ω–∞–∂–∞—Ç—å –∫–Ω–æ–ø–∫—É ¬´–ø—Ä–æ–≤–µ—Ä–∏—Ç—å –æ–ø–ª–∞—Ç—É¬ª –¥–ª—è –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è –±–∞–ª–∞–Ω—Å–∞."
    await message.answer(text, reply_markup=invoice_keyboard(url_aaio, payment_id))


@user_router.callback_query(F.data.startswith("check_payment:"))
async def check_payment(call: CallbackQuery, state: FSMContext):
    payment = Aaio()
    data = await state.get_data()
    AaioAPI.check_payment(data.get("payment_url"), payment)
    if not payment.is_success():
        db = Database()
        top_up = data.get("top_up")
        await call.message.delete()
        await call.message.answer("–£—Å–ø–µ—à–Ω–æ –æ–ø–ª–∞—á–µ–Ω–æ!\n"
                                  "–î–µ–Ω—å–≥–∏ –∑–∞—á–∏—Å–ª–µ–Ω—ã –Ω–∞ —Å—á—ë—Ç!")
        db.update_user_fiat_balance(user_id=call.message.chat.id,
                                    new_fiat_balance=int(top_up) + int(db.select_user(user_id=call.message.chat.id)[4]))
    else:
        await call.answer("–ù–µ –æ–ø–ª–∞—á–µ–Ω–æ!\n–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤—ã –æ–ø–ª–∞—Ç–∏–ª–∏", show_alert=True)


@user_router.callback_query(F.data == "vivod")
async def check_payment(call: CallbackQuery, state: FSMContext):
    db = Database()
    user = db.select_user(user_id=call.message.chat.id)
    users_crypto_balance = db.select_crypto_balances(user_id=call.message.chat.id)
    usdt = users_crypto_balance[2]
    eth = users_crypto_balance[3]
    btc = users_crypto_balance[4]
    currency = user[8]
    await call.message.edit_caption(caption=f"–í–≤–µ–¥–∏—Ç–µ —Å—É–º–º—É –≤—ã–≤–æ–¥–∞:"
                                            f"\n–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ - {hbold('100‚ÇΩ')}"
                                            f"\n–î–æ—Å—Ç—É–ø–Ω—ã–π –±–∞–ª–∞–Ω—Å: {convert_to_rubles(usdt, eth, btc, user[4], currency) - convert_to_rubles(usdt, eth, btc, 0, currency)}")
    await state.set_state(Popoln.sum)


@user_router.message(Popoln.sum)
async def popoln_sum(message: Message, state: FSMContext):
    db = Database()
    user = db.select_user(user_id=message.from_user.id)
    users_crypto_balance = db.select_crypto_balances(user_id=message.from_user.id)
    usdt = users_crypto_balance[2]
    eth = users_crypto_balance[3]
    btc = users_crypto_balance[4]
    currency = user[8]
    balance = convert_to_rubles(usdt, eth, btc, user[4], currency) - convert_to_rubles(usdt, eth, btc, 0, currency)
    if int(message.text) < 100:
        await message.answer("–í—ã –≤–≤–µ–ª–∏ —Å—É–º–º—É –º–µ–Ω—å—à–µ 100‚ÇΩ")
        return
    if int(message.text) > balance:
        await message.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–ª–∞–Ω—Å–∞!")
        return
    await state.update_data(vivod_sum=message.text)
    text = "‚ôªÔ∏è –í—ã–≤–æ–¥:" \
           f"\n\n–°—É–º–º–∞: {message.text}‚ÇΩ\n" \
           f"–í—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç–æ–¥:"
    await message.answer(text, reply_markup=choose_method_keyboard())


@user_router.callback_query(F.data.startswith("choose_method:"))
async def choose_method(call: CallbackQuery, state: FSMContext):
    await state.update_data(method=call.data.split(":")[1])
    await call.message.answer("–û—Ç–ø—Ä–∞–≤—å –Ω–æ–º–µ—Ä –∫–æ—à–µ–ª—å–∫–∞/–∫–∞—Ä—Ç—ã:")
    await state.set_state(Popoln.wallet)


@user_router.message(Popoln.wallet)
async def popoln_wallet(message: Message, state: FSMContext):
    data = await state.get_data()
    vivod_sum = data.get("vivod_sum")
    method = data.get("method")
    if method == "USDT":
        method = "tether_trc20"
    elif method == "BTC":
        method = "bitcoin"
    elif method == "RUB":
        method = "cards_ru"
    create_payoff("864ef93a855b48a4520c4ebccf2e3435",
                  f"{message.from_user.id}:{random.randint(100, 999)}",
                  method,
                  vivod_sum,
                  message.text,
                  0)
    await message.answer("–í—ã–≤–æ–¥ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω!")


@user_router.message(F.text == "üìä –û–±–º–µ–Ω")
async def exchange_reply_button(message: Message, state: FSMContext):
    await message.answer("–í—ã–±–µ—Ä–∏ –≤–∞–ª—é—Ç—É –¥–ª—è –æ–±–º–µ–Ω–∞:", reply_markup=currency_choose())


@user_router.message(F.text == "–†—É–±–ª–∏")
async def rubles_exchange(message: Message, state: FSMContext):
    await state.update_data(currency="RUB")
    await message.answer("–°–∫–æ–ª—å–∫–æ –í—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–º–µ–Ω—è—Ç—å?:")
    await state.set_state(CurrencyExchange.sum)


@user_router.message(F.text == "ETH")
async def rubles_exchange(message: Message, state: FSMContext):
    await state.update_data(currency="ETH")
    await message.answer("–°–∫–æ–ª—å–∫–æ –í—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–º–µ–Ω—è—Ç—å?:")
    await state.set_state(CurrencyExchange.sum)


@user_router.message(F.text == "BTC")
async def rubles_exchange(message: Message, state: FSMContext):
    await state.update_data(currency="BTC")
    await message.answer("–°–∫–æ–ª—å–∫–æ –í—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–º–µ–Ω—è—Ç—å?:")
    await state.set_state(CurrencyExchange.sum)


@user_router.message(F.text == "USD")
async def rubles_exchange(message: Message, state: FSMContext):
    await state.update_data(currency="USD")
    await message.answer("–°–∫–æ–ª—å–∫–æ –í—ã —Ö–æ—Ç–∏—Ç–µ –ø–æ–º–µ–Ω—è—Ç—å?:")
    await state.set_state(CurrencyExchange.sum)


@user_router.message(CurrencyExchange.sum)
async def currency_exchange_sum(message: Message, state: FSMContext):
    data = await state.get_data()
    db = Database()
    await state.update_data(exchange_sum=message.text)
    user = db.select_user(user_id=message.from_user.id)
    users_crypto_balance = db.select_crypto_balances(user_id=message.from_user.id)
    usdt = users_crypto_balance[2]
    eth = users_crypto_balance[3]
    btc = users_crypto_balance[4]
    currency = user[8]
    balance = convert_to_rubles(usdt, eth, btc, user[4], currency) - convert_to_rubles(usdt, eth, btc, 0, currency)
    if int(message.text) > balance:
        await message.answer("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±–∞–ª–∞–Ω—Å–∞!")
        return
    currency = data.get("currency")
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –≤–∞–ª—é—Ç—É, –∫–æ—Ç–æ—Ä—É—é —Ö–æ—Ç–∏—Ç–µ –ø–æ–ª—É—á–∏—Ç—å:", reply_markup=exchange_keyboard(currency))


@user_router.callback_query(F.data.startswith("exchange:"))
async def final_exchange(call: CallbackQuery, state: FSMContext):
    db = Database()
    data = await state.get_data()
    exchange_sum = int(data.get("exchange_sum"))
    user = db.select_user(user_id=call.message.chat.id)
    currency = data.get("currency")
    changing_currency = call.data.split(":")[1]
    users_crypto_balance = db.select_crypto_balances(user_id=call.message.chat.id)
    usdt = users_crypto_balance[2]
    eth = users_crypto_balance[3]
    btc = users_crypto_balance[4]
    extra_charge = float(db.select_extra_charge()[0][1])
    dollar_to_ruble = get_usd_to_rubles_rate()
    fiat_balance = round(convert_to_rubles(usdt, eth, btc, user[4], "RUB") - convert_to_rubles(usdt, eth, btc, 0, "RUB"))
    if currency == "RUB":
        response = requests.get("https://api.coinbase.com/v2/exchange-rates?currency=RUB")
        data = response.json()
        if changing_currency == "BTC":
            rate = float(data.get('data').get('rates').get('BTC'))
            db.update_btc_balance(user_id=call.message.chat.id, new_btc_balance=btc + exchange_sum * (rate - rate * extra_charge))
            db.update_user_fiat_balance(user_id=call.message.chat.id,
                                        new_fiat_balance=(fiat_balance - exchange_sum) / float(dollar_to_ruble))
        elif changing_currency == "ETH":
            rate = float(data.get('data').get('rates').get('ETH'))
            db.update_eth_balance(user_id=call.message.chat.id, new_eth_balance=eth + exchange_sum * (rate - rate * extra_charge))
            db.update_user_fiat_balance(user_id=call.message.chat.id,
                                        new_fiat_balance=(fiat_balance - exchange_sum) / float(dollar_to_ruble))
        elif changing_currency == "USDT":
            rate = float(data.get('data').get('rates').get('USDT'))
            print(exchange_sum)
            print(rate - rate * extra_charge)
            db.update_usdt_balance(user_id=call.message.chat.id, new_usdt_balance=usdt + exchange_sum * (rate - rate * extra_charge))
            db.update_user_fiat_balance(user_id=call.message.chat.id,
                                        new_fiat_balance=(fiat_balance - exchange_sum) / float(dollar_to_ruble))
    elif currency == "BTC":
        response = requests.get("https://api.coinbase.com/v2/exchange-rates?currency=BTC")
        data = response.json()
        if changing_currency == "RUB":
            rate = float(data.get('data').get('rates').get('RUB'))
            db.update_user_fiat_balance(user_id=call.message.chat.id,
                                        new_fiat_balance=fiat_balance + exchange_sum * (rate - rate * extra_charge))
            db.update_btc_balance(user_id=call.message.chat.id, new_btc_balance=btc - exchange_sum)
        elif changing_currency == "ETH":
            rate = float(data.get('data').get('rates').get('ETH'))
            db.update_eth_balance(user_id=call.message.chat.id, new_eth_balance=eth + exchange_sum * (rate - rate * extra_charge))
            db.update_btc_balance(user_id=call.message.chat.id, new_btc_balance=btc - exchange_sum)
        elif changing_currency == "USDT":
            rate = float(data.get('data').get('rates').get('USDT'))
            db.update_usdt_balance(user_id=call.message.chat.id, new_usdt_balance=usdt + exchange_sum * (rate - rate * extra_charge))
            db.update_btc_balance(user_id=call.message.chat.id, new_btc_balance=btc - exchange_sum)
    elif currency == "ETH":
        response = requests.get("https://api.coinbase.com/v2/exchange-rates?currency=ETH")
        data = response.json()
        if changing_currency == "BTC":
            rate = float(data.get('data').get('rates').get('BTC'))
            db.update_btc_balance(user_id=call.message.chat.id, new_btc_balance=btc + exchange_sum * (rate - rate * extra_charge))
            db.update_eth_balance(user_id=call.message.chat.id, new_eth_balance=eth - exchange_sum)
        elif changing_currency == "RUB":
            rate = float(data.get('data').get('rates').get('RUB'))
            db.update_user_fiat_balance(user_id=call.message.chat.id,
                                        new_fiat_balance=fiat_balance + exchange_sum * (rate - rate * extra_charge))
            db.update_eth_balance(user_id=call.message.chat.id, new_eth_balance=eth - exchange_sum)
        elif changing_currency == "USDT":
            rate = float(data.get('data').get('rates').get('USDT'))
            db.update_usdt_balance(user_id=call.message.chat.id, new_usdt_balance=usdt + exchange_sum * (rate - rate * extra_charge))
            db.update_eth_balance(user_id=call.message.chat.id, new_eth_balance=eth - exchange_sum)
    elif currency == "USDT":
        response = requests.get("https://api.coinbase.com/v2/exchange-rates?currency=USDT")
        data = response.json()
        if changing_currency == "BTC":
            rate = float(data.get('data').get('rates').get('BTC'))
            db.update_btc_balance(user_id=call.message.chat.id, new_btc_balance=btc + exchange_sum * (rate - rate * extra_charge))
            db.update_usdt_balance(user_id=call.message.chat.id, new_usdt_balance=usdt - exchange_sum)
        elif changing_currency == "RUB":
            rate = float(data.get('data').get('rates').get('RUB'))
            db.update_user_fiat_balance(user_id=call.message.chat.id, new_fiat_balance=fiat_balance + exchange_sum * (rate - rate * extra_charge))
            db.update_usdt_balance(user_id=call.message.chat.id, new_usdt_balance=usdt - exchange_sum)
        elif changing_currency == "ETH":
            rate = float(data.get('data').get('rates').get('ETH'))
            db.update_eth_balance(user_id=call.message.chat.id, new_eth_balance=eth + exchange_sum * (rate - rate * extra_charge))
            db.update_usdt_balance(user_id=call.message.chat.id, new_usdt_balance=usdt - exchange_sum)
    await call.message.answer("–£—Å–ø–µ—à–Ω–æ –æ–±–º–µ–Ω–µ–Ω–æ!")
    await state.clear()
